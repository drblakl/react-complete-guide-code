"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
<<<<<<< HEAD
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _pluginSyntaxFlow = require("@babel/plugin-syntax-flow");
var _core = require("@babel/core");
var _default = (0, _helperPluginUtils.declare)((api, opts) => {
  api.assertVersion(7);
  const FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
  let skipStrip = false;
  const {
    requireDirective = false
  } = opts;
  {
    var {
      allowDeclareFields = false
    } = opts;
  }
  return {
    name: "transform-flow-strip-types",
    inherits: _pluginSyntaxFlow.default,
=======

function _helperPluginUtils() {
  const data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function () {
    return data;
  };

  return data;
}

function _pluginSyntaxFlow() {
  const data = _interopRequireDefault(require("@babel/plugin-syntax-flow"));

  _pluginSyntaxFlow = function () {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@babel/core");

  _core = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _helperPluginUtils().declare)(api => {
  api.assertVersion(7);
  const FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
  let skipStrip = false;
  return {
    name: "transform-flow-strip-types",
    inherits: _pluginSyntaxFlow().default,
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    visitor: {
      Program(path, {
        file: {
          ast: {
            comments
          }
<<<<<<< HEAD
        }
      }) {
        skipStrip = false;
        let directiveFound = false;
=======
        },
        opts
      }) {
        skipStrip = false;
        let directiveFound = false;

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        if (comments) {
          for (const comment of comments) {
            if (FLOW_DIRECTIVE.test(comment.value)) {
              directiveFound = true;
              comment.value = comment.value.replace(FLOW_DIRECTIVE, "");
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
              if (!comment.value.replace(/\*/g, "").trim()) {
                comment.ignore = true;
              }
            }
          }
        }
<<<<<<< HEAD
        if (!directiveFound && requireDirective) {
          skipStrip = true;
        }
      },
=======

        if (!directiveFound && opts.requireDirective) {
          skipStrip = true;
        }
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      ImportDeclaration(path) {
        if (skipStrip) return;
        if (!path.node.specifiers.length) return;
        let typeCount = 0;
        path.node.specifiers.forEach(({
          importKind
        }) => {
          if (importKind === "type" || importKind === "typeof") {
            typeCount++;
          }
        });
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        if (typeCount === path.node.specifiers.length) {
          path.remove();
        }
      },
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      Flow(path) {
        if (skipStrip) {
          throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
        }
<<<<<<< HEAD
        path.remove();
      },
=======

        path.remove();
      },

      ClassProperty(path) {
        if (skipStrip) return;
        path.node.variance = null;
        path.node.typeAnnotation = null;
        if (!path.node.value) path.remove();
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      ClassPrivateProperty(path) {
        if (skipStrip) return;
        path.node.typeAnnotation = null;
      },
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      Class(path) {
        if (skipStrip) return;
        path.node.implements = null;
        path.get("body.body").forEach(child => {
          if (child.isClassProperty()) {
<<<<<<< HEAD
            const {
              node
            } = child;
            {
              if (!allowDeclareFields && node.declare) {
                throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);
              }
            }
            if (node.declare) {
              child.remove();
            } else {
              {
                if (!allowDeclareFields && !node.value && !node.decorators) {
                  child.remove();
                  return;
                }
              }
              node.variance = null;
              node.typeAnnotation = null;
            }
          }
        });
      },
=======
            child.node.typeAnnotation = null;
            if (!child.node.value) child.remove();
          }
        });
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      AssignmentPattern({
        node
      }) {
        if (skipStrip) return;
<<<<<<< HEAD
        if (node.left.optional) {
          node.left.optional = false;
        }
      },
=======
        node.left.optional = false;
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      Function({
        node
      }) {
        if (skipStrip) return;
<<<<<<< HEAD
        if (node.params.length > 0 && node.params[0].type === "Identifier" && node.params[0].name === "this") {
          node.params.shift();
        }
        for (let i = 0; i < node.params.length; i++) {
          let param = node.params[i];
          if (param.type === "AssignmentPattern") {
            param = param.left;
          }
          if (param.optional) {
            param.optional = false;
          }
        }
        if (!_core.types.isMethod(node)) {
          node.predicate = null;
        }
      },
=======

        for (let i = 0; i < node.params.length; i++) {
          const param = node.params[i];
          param.optional = false;

          if (param.type === "AssignmentPattern") {
            param.left.optional = false;
          }
        }

        node.predicate = null;
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      TypeCastExpression(path) {
        if (skipStrip) return;
        let {
          node
        } = path;
<<<<<<< HEAD
        do {
          node = node.expression;
        } while (_core.types.isTypeCastExpression(node));
        path.replaceWith(node);
      },
=======

        do {
          node = node.expression;
        } while (_core().types.isTypeCastExpression(node));

        path.replaceWith(node);
      },

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      CallExpression({
        node
      }) {
        if (skipStrip) return;
        node.typeArguments = null;
      },
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      OptionalCallExpression({
        node
      }) {
        if (skipStrip) return;
        node.typeArguments = null;
      },
<<<<<<< HEAD
=======

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      NewExpression({
        node
      }) {
        if (skipStrip) return;
        node.typeArguments = null;
      }
<<<<<<< HEAD
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
=======

    }
  };
});

exports.default = _default;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
