/**
 * @fileoverview Prevent void elements (e.g. <img />, <br />) from receiving
 *   children
 * @author Joe Lencioni
 */
<<<<<<< HEAD

'use strict';

const has = require('object.hasown/polyfill')();

const docsUrl = require('../util/docsUrl');
const isCreateElement = require('../util/isCreateElement');
const report = require('../util/report');
=======
'use strict';

const has = require('has');

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

// ------------------------------------------------------------------------------
// Helpers
// ------------------------------------------------------------------------------

// Using an object here to avoid array scan. We should switch to Set once
// support is good enough.
const VOID_DOM_ELEMENTS = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  menuitem: true,
  meta: true,
  param: true,
  source: true,
  track: true,
<<<<<<< HEAD
  wbr: true,
=======
  wbr: true
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
};

function isVoidDOMElement(elementName) {
  return has(VOID_DOM_ELEMENTS, elementName);
}

<<<<<<< HEAD
=======
function errorMessage(elementName) {
  return `Void DOM element <${elementName} /> cannot receive children.`;
}

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
const noChildrenInVoidEl = 'Void DOM element <{{element}} /> cannot receive children.';

module.exports = {
  meta: {
    docs: {
      description: 'Disallow void DOM elements (e.g. `<img />`, `<br />`) from receiving children',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('void-dom-elements-no-children'),
    },

    messages: {
      noChildrenInVoidEl,
    },

    schema: [],
  },

  create: (context) => ({
    JSXElement(node) {
=======
module.exports = {
  meta: {
    docs: {
      description: 'Prevent passing of children to void DOM elements (e.g. <br />).',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('void-dom-elements-no-children')
    },
    schema: []
  },

  create: Components.detect((context, components, utils) => ({
    JSXElement: function(node) {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      const elementName = node.openingElement.name.name;

      if (!isVoidDOMElement(elementName)) {
        // e.g. <div />
        return;
      }

      if (node.children.length > 0) {
        // e.g. <br>Foo</br>
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node: node,
          message: errorMessage(elementName)
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        });
      }

      const attributes = node.openingElement.attributes;

<<<<<<< HEAD
      const hasChildrenAttributeOrDanger = attributes.some((attribute) => {
=======
      const hasChildrenAttributeOrDanger = attributes.some(attribute => {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        if (!attribute.name) {
          return false;
        }

        return attribute.name.name === 'children' || attribute.name.name === 'dangerouslySetInnerHTML';
      });

      if (hasChildrenAttributeOrDanger) {
        // e.g. <br children="Foo" />
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node: node,
          message: errorMessage(elementName)
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        });
      }
    },

<<<<<<< HEAD
    CallExpression(node) {
=======
    CallExpression: function(node) {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
      if (node.callee.type !== 'MemberExpression' && node.callee.type !== 'Identifier') {
        return;
      }

<<<<<<< HEAD
      if (!isCreateElement(node, context)) {
=======
      if (!utils.isReactCreateElement(node)) {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        return;
      }

      const args = node.arguments;

      if (args.length < 1) {
        // React.createElement() should not crash linter
        return;
      }

      const elementName = args[0].value;

      if (!isVoidDOMElement(elementName)) {
        // e.g. React.createElement('div');
        return;
      }

      if (args.length < 2 || args[1].type !== 'ObjectExpression') {
        return;
      }

      const firstChild = args[2];
      if (firstChild) {
        // e.g. React.createElement('br', undefined, 'Foo')
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node: node,
          message: errorMessage(elementName)
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        });
      }

      const props = args[1].properties;

<<<<<<< HEAD
      const hasChildrenPropOrDanger = props.some((prop) => {
=======
      const hasChildrenPropOrDanger = props.some(prop => {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        if (!prop.key) {
          return false;
        }

        return prop.key.name === 'children' || prop.key.name === 'dangerouslySetInnerHTML';
      });

      if (hasChildrenPropOrDanger) {
        // e.g. React.createElement('br', { children: 'Foo' })
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
        });
      }
    },
  }),
=======
        context.report({
          node: node,
          message: errorMessage(elementName)
        });
      }
    }
  }))
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
};
