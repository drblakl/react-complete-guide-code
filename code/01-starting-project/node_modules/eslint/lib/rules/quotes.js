/**
 * @fileoverview A rule to choose between single and double quote marks
 * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");
=======
const astUtils = require("../util/ast-utils");
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const QUOTE_SETTINGS = {
    double: {
        quote: "\"",
        alternateQuote: "'",
        description: "doublequote"
    },
    single: {
        quote: "'",
        alternateQuote: "\"",
        description: "singlequote"
    },
    backtick: {
        quote: "`",
        alternateQuote: "\"",
        description: "backtick"
    }
};

// An unescaped newline is a newline preceded by an even number of backslashes.
<<<<<<< HEAD
const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`, "u");
=======
const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

/**
 * Switches quoting of javascript string between ' " and `
 * escaping and unescaping as necessary.
 * Only escaping of the minimal set of characters is changed.
 * Note: escaping of newlines when switching from backtick to other quotes is not handled.
<<<<<<< HEAD
 * @param {string} str A string to convert.
=======
 * @param {string} str - A string to convert.
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
 * @returns {string} The string with changed quotes.
 * @private
 */
QUOTE_SETTINGS.double.convert =
QUOTE_SETTINGS.single.convert =
QUOTE_SETTINGS.backtick.convert = function(str) {
    const newQuote = this.quote;
    const oldQuote = str[0];

    if (newQuote === oldQuote) {
        return str;
    }
<<<<<<< HEAD
    return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
=======
    return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, (match, escaped, newline) => {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
            return escaped; // unescape
        }
        if (match === newQuote || newQuote === "`" && match === "${") {
            return `\\${match}`; // escape
        }
        if (newline && oldQuote === "`") {
            return "\\n"; // escape newlines
        }
        return match;
    }) + newQuote;
};

const AVOID_ESCAPE = "avoid-escape";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "Enforce the consistent use of either backticks, double, or single quotes",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/quotes"
=======
module.exports = {
    meta: {
        docs: {
            description: "enforce the consistent use of either backticks, double, or single quotes",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/quotes"
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        },

        fixable: "code",

        schema: [
            {
                enum: ["single", "double", "backtick"]
            },
            {
                anyOf: [
                    {
                        enum: ["avoid-escape"]
                    },
                    {
                        type: "object",
                        properties: {
                            avoidEscape: {
                                type: "boolean"
                            },
                            allowTemplateLiterals: {
                                type: "boolean"
                            }
                        },
                        additionalProperties: false
                    }
                ]
            }
<<<<<<< HEAD
        ],

        messages: {
            wrongQuotes: "Strings must use {{description}}."
        }
=======
        ]
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    },

    create(context) {

        const quoteOption = context.options[0],
            settings = QUOTE_SETTINGS[quoteOption || "double"],
            options = context.options[1],
            allowTemplateLiterals = options && options.allowTemplateLiterals === true,
<<<<<<< HEAD
            sourceCode = context.sourceCode;
=======
            sourceCode = context.getSourceCode();
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        let avoidEscape = options && options.avoidEscape === true;

        // deprecated
        if (options === AVOID_ESCAPE) {
            avoidEscape = true;
        }

        /**
         * Determines if a given node is part of JSX syntax.
         *
         * This function returns `true` in the following cases:
         *
         * - `<div className="foo"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.
         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.
         * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.
         *
         * In particular, this function returns `false` in the following cases:
         *
         * - `<div className={"foo"}></div>`
         * - `<div>{"foo"}</div>`
         *
         * In both cases, inside of the braces is handled as normal JavaScript.
         * The braces are `JSXExpressionContainer` nodes.
<<<<<<< HEAD
=======
         *
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
         * @param {ASTNode} node The Literal node to check.
         * @returns {boolean} True if the node is a part of JSX, false if not.
         * @private
         */
        function isJSXLiteral(node) {
            return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
        }

        /**
         * Checks whether or not a given node is a directive.
<<<<<<< HEAD
         * The directive is a `ExpressionStatement` which has only a string literal not surrounded by
         * parentheses.
         * @param {ASTNode} node A node to check.
=======
         * The directive is a `ExpressionStatement` which has only a string literal.
         * @param {ASTNode} node - A node to check.
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
         * @returns {boolean} Whether or not the node is a directive.
         * @private
         */
        function isDirective(node) {
            return (
                node.type === "ExpressionStatement" &&
                node.expression.type === "Literal" &&
<<<<<<< HEAD
                typeof node.expression.value === "string" &&
                !astUtils.isParenthesised(sourceCode, node.expression)
=======
                typeof node.expression.value === "string"
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
            );
        }

        /**
<<<<<<< HEAD
         * Checks whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.
         * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive}
         * @param {ASTNode} node A node to check.
         * @returns {boolean} Whether a specified node is either part of, or immediately follows a (possibly empty) directive prologue.
         * @private
         */
        function isExpressionInOrJustAfterDirectivePrologue(node) {
            if (!astUtils.isTopLevelExpressionStatement(node.parent)) {
                return false;
            }
            const block = node.parent.parent;
=======
         * Checks whether or not a given node is a part of directive prologues.
         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive
         * @param {ASTNode} node - A node to check.
         * @returns {boolean} Whether or not the node is a part of directive prologues.
         * @private
         */
        function isPartOfDirectivePrologue(node) {
            const block = node.parent.parent;

            if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
                return false;
            }
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

            // Check the node is at a prologue.
            for (let i = 0; i < block.body.length; ++i) {
                const statement = block.body[i];

                if (statement === node.parent) {
                    return true;
                }
                if (!isDirective(statement)) {
                    break;
                }
            }

            return false;
        }

        /**
         * Checks whether or not a given node is allowed as non backtick.
<<<<<<< HEAD
         * @param {ASTNode} node A node to check.
=======
         * @param {ASTNode} node - A node to check.
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
         * @returns {boolean} Whether or not the node is allowed as non backtick.
         * @private
         */
        function isAllowedAsNonBacktick(node) {
            const parent = node.parent;

            switch (parent.type) {

                // Directive Prologues.
                case "ExpressionStatement":
<<<<<<< HEAD
                    return !astUtils.isParenthesised(sourceCode, node) && isExpressionInOrJustAfterDirectivePrologue(node);

                // LiteralPropertyName.
                case "Property":
                case "PropertyDefinition":
=======
                    return isPartOfDirectivePrologue(node);

                // LiteralPropertyName.
                case "Property":
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                case "MethodDefinition":
                    return parent.key === node && !parent.computed;

                // ModuleSpecifier.
                case "ImportDeclaration":
                case "ExportNamedDeclaration":
<<<<<<< HEAD
                    return parent.source === node;

                // ModuleExportName or ModuleSpecifier.
                case "ExportAllDeclaration":
                    return parent.exported === node || parent.source === node;

                // ModuleExportName.
                case "ImportSpecifier":
                    return parent.imported === node;

                // ModuleExportName.
                case "ExportSpecifier":
                    return parent.local === node || parent.exported === node;
=======
                case "ExportAllDeclaration":
                    return parent.source === node;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

                // Others don't allow.
                default:
                    return false;
            }
        }

<<<<<<< HEAD
        /**
         * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.
         * @param {ASTNode} node A TemplateLiteral node to check.
         * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.
         * @private
         */
        function isUsingFeatureOfTemplateLiteral(node) {
            const hasTag = node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi;

            if (hasTag) {
                return true;
            }

            const hasStringInterpolation = node.expressions.length > 0;

            if (hasStringInterpolation) {
                return true;
            }

            const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);

            if (isMultilineString) {
                return true;
            }

            return false;
        }

=======
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        return {

            Literal(node) {
                const val = node.value,
                    rawVal = node.raw;

                if (settings && typeof val === "string") {
                    let isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) ||
                        isJSXLiteral(node) ||
                        astUtils.isSurroundedBy(rawVal, settings.quote);

                    if (!isValid && avoidEscape) {
<<<<<<< HEAD
                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.includes(settings.quote);
=======
                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                    }

                    if (!isValid) {
                        context.report({
                            node,
<<<<<<< HEAD
                            messageId: "wrongQuotes",
=======
                            message: "Strings must use {{description}}.",
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                            data: {
                                description: settings.description
                            },
                            fix(fixer) {
<<<<<<< HEAD
                                if (quoteOption === "backtick" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {

                                    /*
                                     * An octal or non-octal decimal escape sequence in a template literal would
                                     * produce syntax error, even in non-strict mode.
                                     */
                                    return null;
                                }

=======
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                                return fixer.replaceText(node, settings.convert(node.raw));
                            }
                        });
                    }
                }
            },

            TemplateLiteral(node) {

<<<<<<< HEAD
                // Don't throw an error if backticks are expected or a template literal feature is in use.
                if (
                    allowTemplateLiterals ||
                    quoteOption === "backtick" ||
                    isUsingFeatureOfTemplateLiteral(node)
=======
                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors
                if (
                    allowTemplateLiterals ||
                    quoteOption === "backtick" ||
                    node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                ) {
                    return;
                }

<<<<<<< HEAD
                context.report({
                    node,
                    messageId: "wrongQuotes",
                    data: {
                        description: settings.description
                    },
                    fix(fixer) {
                        if (astUtils.isTopLevelExpressionStatement(node.parent) && !astUtils.isParenthesised(sourceCode, node)) {

                            /*
                             * TemplateLiterals aren't actually directives, but fixing them might turn
                             * them into directives and change the behavior of the code.
                             */
                            return null;
                        }
                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
                    }
                });
=======
                // A warning should be produced if the template literal only has one TemplateElement, and has no unescaped newlines.
                const shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);

                if (shouldWarn) {
                    context.report({
                        node,
                        message: "Strings must use {{description}}.",
                        data: {
                            description: settings.description
                        },
                        fix(fixer) {
                            if (isPartOfDirectivePrologue(node)) {

                                /*
                                 * TemplateLiterals in a directive prologue aren't actually directives, but if they're
                                 * in the directive prologue, then fixing them might turn them into directives and change
                                 * the behavior of the code.
                                 */
                                return null;
                            }
                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
                        }
                    });
                }
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
            }
        };

    }
};
