/**
 * @fileoverview Rule to ensure newline per method call when chaining calls
 * @author Rajendra Patil
 * @author Burak Yigit Kaya
 */

"use strict";

<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");
=======
const astUtils = require("../util/ast-utils");
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "Require a newline after each call in a method chain",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/newline-per-chained-call"
        },

        fixable: "whitespace",

=======
module.exports = {
    meta: {
        docs: {
            description: "require a newline after each call in a method chain",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/newline-per-chained-call"
        },
        fixable: "whitespace",
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        schema: [{
            type: "object",
            properties: {
                ignoreChainWithDepth: {
                    type: "integer",
                    minimum: 1,
<<<<<<< HEAD
                    maximum: 10,
                    default: 2
                }
            },
            additionalProperties: false
        }],
        messages: {
            expected: "Expected line break before `{{callee}}`."
        }
=======
                    maximum: 10
                }
            },
            additionalProperties: false
        }]
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    },

    create(context) {

        const options = context.options[0] || {},
            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

<<<<<<< HEAD
        const sourceCode = context.sourceCode;
=======
        const sourceCode = context.getSourceCode();
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

        /**
         * Get the prefix of a given MemberExpression node.
         * If the MemberExpression node is a computed value it returns a
         * left bracket. If not it returns a period.
<<<<<<< HEAD
         * @param {ASTNode} node A MemberExpression node to get
         * @returns {string} The prefix of the node.
         */
        function getPrefix(node) {
            if (node.computed) {
                if (node.optional) {
                    return "?.[";
                }
                return "[";
            }
            if (node.optional) {
                return "?.";
            }
            return ".";
=======
         *
         * @param  {ASTNode} node - A MemberExpression node to get
         * @returns {string} The prefix of the node.
         */
        function getPrefix(node) {
            return node.computed ? "[" : ".";
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        }

        /**
         * Gets the property text of a given MemberExpression node.
         * If the text is multiline, this returns only the first line.
<<<<<<< HEAD
         * @param {ASTNode} node A MemberExpression node to get.
=======
         *
         * @param {ASTNode} node - A MemberExpression node to get.
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
         * @returns {string} The property text of the node.
         */
        function getPropertyText(node) {
            const prefix = getPrefix(node);
            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
            const suffix = node.computed && lines.length === 1 ? "]" : "";

            return prefix + lines[0] + suffix;
        }

        return {
            "CallExpression:exit"(node) {
<<<<<<< HEAD
                const callee = astUtils.skipChainExpression(node.callee);

                if (callee.type !== "MemberExpression") {
                    return;
                }

                let parent = astUtils.skipChainExpression(callee.object);
=======
                if (!node.callee || node.callee.type !== "MemberExpression") {
                    return;
                }

                const callee = node.callee;
                let parent = callee.object;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                let depth = 1;

                while (parent && parent.callee) {
                    depth += 1;
<<<<<<< HEAD
                    parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);
                }

                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
                    const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);

                    context.report({
                        node: callee.property,
                        loc: {
                            start: firstTokenAfterObject.loc.start,
                            end: callee.loc.end
                        },
                        messageId: "expected",
=======
                    parent = parent.callee.object;
                }

                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
                    context.report({
                        node: callee.property,
                        loc: callee.property.loc.start,
                        message: "Expected line break before `{{callee}}`.",
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                        data: {
                            callee: getPropertyText(callee)
                        },
                        fix(fixer) {
<<<<<<< HEAD
=======
                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                            return fixer.insertTextBefore(firstTokenAfterObject, "\n");
                        }
                    });
                }
            }
        };
    }
};
