/**
 * @fileoverview Rule to require or disallow yoda comparisons
 * @author Nicholas C. Zakas
 */
"use strict";

//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------

<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");
=======
const astUtils = require("../util/ast-utils");
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines whether an operator is a comparison operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is a comparison operator.
 */
function isComparisonOperator(operator) {
<<<<<<< HEAD
    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);
=======
    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
}

/**
 * Determines whether an operator is an equality operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is an equality operator.
 */
function isEqualityOperator(operator) {
<<<<<<< HEAD
    return /^(==|===)$/u.test(operator);
=======
    return (/^(==|===)$/).test(operator);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
}

/**
 * Determines whether an operator is one used in a range test.
 * Allowed operators are `<` and `<=`.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether the operator is used in range tests.
 */
function isRangeTestOperator(operator) {
<<<<<<< HEAD
    return ["<", "<="].includes(operator);
=======
    return ["<", "<="].indexOf(operator) >= 0;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
}

/**
 * Determines whether a non-Literal node is a negative number that should be
 * treated as if it were a single Literal node.
 * @param {ASTNode} node Node to test.
 * @returns {boolean} True if the node is a negative number that looks like a
 *                    real literal and should be treated as such.
 */
<<<<<<< HEAD
function isNegativeNumericLiteral(node) {
    return (
        node.type === "UnaryExpression" &&
        node.operator === "-" &&
        node.prefix &&
        astUtils.isNumericLiteral(node.argument)
    );
}

/**
 * Determines whether a non-Literal node should be treated as a single Literal node.
 * @param {ASTNode} node Node to test
 * @returns {boolean} True if the node should be treated as a single Literal node.
 */
function looksLikeLiteral(node) {
    return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);
=======
function looksLikeLiteral(node) {
    return (node.type === "UnaryExpression" &&
        node.operator === "-" &&
        node.prefix &&
        node.argument.type === "Literal" &&
        typeof node.argument.value === "number");
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
}

/**
 * Attempts to derive a Literal node from nodes that are treated like literals.
 * @param {ASTNode} node Node to normalize.
<<<<<<< HEAD
=======
 * @param {number} [defaultValue] The default value to be returned if the node
 *                                is not a Literal.
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
 * @returns {ASTNode} One of the following options.
 *  1. The original node if the node is already a Literal
 *  2. A normalized Literal node with the negative number as the value if the
 *     node represents a negative number literal.
<<<<<<< HEAD
 *  3. A normalized Literal node with the string as the value if the node is
 *     a Template Literal without expression.
 *  4. Otherwise `null`.
 */
function getNormalizedLiteral(node) {
=======
 *  3. The Literal node which has the `defaultValue` argument if it exists.
 *  4. Otherwise `null`.
 */
function getNormalizedLiteral(node, defaultValue) {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    if (node.type === "Literal") {
        return node;
    }

<<<<<<< HEAD
    if (isNegativeNumericLiteral(node)) {
=======
    if (looksLikeLiteral(node)) {
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        return {
            type: "Literal",
            value: -node.argument.value,
            raw: `-${node.argument.value}`
        };
    }

<<<<<<< HEAD
    if (astUtils.isStaticTemplateLiteral(node)) {
        return {
            type: "Literal",
            value: node.quasis[0].value.cooked,
            raw: node.quasis[0].value.raw
=======
    if (defaultValue) {
        return {
            type: "Literal",
            value: defaultValue,
            raw: String(defaultValue)
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        };
    }

    return null;
}

<<<<<<< HEAD
=======
/**
 * Checks whether two expressions reference the same value. For example:
 *     a = a
 *     a.b = a.b
 *     a[0] = a[0]
 *     a['b'] = a['b']
 * @param   {ASTNode} a Left side of the comparison.
 * @param   {ASTNode} b Right side of the comparison.
 * @returns {boolean}   True if both sides match and reference the same value.
 */
function same(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    switch (a.type) {
        case "Identifier":
            return a.name === b.name;

        case "Literal":
            return a.value === b.value;

        case "MemberExpression": {
            const nameA = astUtils.getStaticPropertyName(a);

            // x.y = x["y"]
            if (nameA) {
                return (
                    same(a.object, b.object) &&
                    nameA === astUtils.getStaticPropertyName(b)
                );
            }

            /*
             * x[0] = x[0]
             * x[y] = x[y]
             * x.y = x.y
             */
            return (
                a.computed === b.computed &&
                same(a.object, b.object) &&
                same(a.property, b.property)
            );
        }

        case "ThisExpression":
            return true;

        default:
            return false;
    }
}

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: 'Require or disallow "Yoda" conditions',
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/yoda"
=======
module.exports = {
    meta: {
        docs: {
            description: "require or disallow \"Yoda\" conditions",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/yoda"
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        },

        schema: [
            {
                enum: ["always", "never"]
            },
            {
                type: "object",
                properties: {
                    exceptRange: {
<<<<<<< HEAD
                        type: "boolean",
                        default: false
                    },
                    onlyEquality: {
                        type: "boolean",
                        default: false
=======
                        type: "boolean"
                    },
                    onlyEquality: {
                        type: "boolean"
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                    }
                },
                additionalProperties: false
            }
        ],

<<<<<<< HEAD
        fixable: "code",
        messages: {
            expected:
                "Expected literal to be on the {{expectedSide}} side of {{operator}}."
        }
=======
        fixable: "code"
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    },

    create(context) {

        // Default to "never" (!always) if no option
<<<<<<< HEAD
        const always = context.options[0] === "always";
        const exceptRange =
            context.options[1] && context.options[1].exceptRange;
        const onlyEquality =
            context.options[1] && context.options[1].onlyEquality;

        const sourceCode = context.sourceCode;
=======
        const always = (context.options[0] === "always");
        const exceptRange = (context.options[1] && context.options[1].exceptRange);
        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);

        const sourceCode = context.getSourceCode();
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

        /**
         * Determines whether node represents a range test.
         * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
         * both operators must be `<` or `<=`. Finally, the literal on the left side
         * must be less than or equal to the literal on the right side so that the
         * test makes any sense.
         * @param {ASTNode} node LogicalExpression node to test.
         * @returns {boolean} Whether node is a range test.
         */
        function isRangeTest(node) {
            const left = node.left,
                right = node.right;

            /**
             * Determines whether node is of the form `0 <= x && x < 1`.
             * @returns {boolean} Whether node is a "between" range test.
             */
            function isBetweenTest() {
<<<<<<< HEAD
                if (node.operator === "&&" && astUtils.isSameReference(left.right, right.left)) {
                    const leftLiteral = getNormalizedLiteral(left.left);
                    const rightLiteral = getNormalizedLiteral(right.right);

                    if (leftLiteral === null && rightLiteral === null) {
                        return false;
                    }

                    if (rightLiteral === null || leftLiteral === null) {
                        return true;
                    }

                    if (leftLiteral.value <= rightLiteral.value) {
                        return true;
                    }
                }
                return false;
=======
                let leftLiteral, rightLiteral;

                return (node.operator === "&&" &&
                    (leftLiteral = getNormalizedLiteral(left.left)) &&
                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&
                    leftLiteral.value <= rightLiteral.value &&
                    same(left.right, right.left));
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
            }

            /**
             * Determines whether node is of the form `x < 0 || 1 <= x`.
             * @returns {boolean} Whether node is an "outside" range test.
             */
            function isOutsideTest() {
<<<<<<< HEAD
                if (node.operator === "||" && astUtils.isSameReference(left.left, right.right)) {
                    const leftLiteral = getNormalizedLiteral(left.right);
                    const rightLiteral = getNormalizedLiteral(right.left);

                    if (leftLiteral === null && rightLiteral === null) {
                        return false;
                    }

                    if (rightLiteral === null || leftLiteral === null) {
                        return true;
                    }

                    if (leftLiteral.value <= rightLiteral.value) {
                        return true;
                    }
                }

                return false;
=======
                let leftLiteral, rightLiteral;

                return (node.operator === "||" &&
                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&
                    (rightLiteral = getNormalizedLiteral(right.left)) &&
                    leftLiteral.value <= rightLiteral.value &&
                    same(left.left, right.right));
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
            }

            /**
             * Determines whether node is wrapped in parentheses.
             * @returns {boolean} Whether node is preceded immediately by an open
             *                    paren token and followed immediately by a close
             *                    paren token.
             */
            function isParenWrapped() {
                return astUtils.isParenthesised(sourceCode, node);
            }

<<<<<<< HEAD
            return (
                node.type === "LogicalExpression" &&
=======
            return (node.type === "LogicalExpression" &&
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                left.type === "BinaryExpression" &&
                right.type === "BinaryExpression" &&
                isRangeTestOperator(left.operator) &&
                isRangeTestOperator(right.operator) &&
                (isBetweenTest() || isOutsideTest()) &&
<<<<<<< HEAD
                isParenWrapped()
            );
=======
                isParenWrapped());
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        }

        const OPERATOR_FLIP_MAP = {
            "===": "===",
            "!==": "!==",
            "==": "==",
            "!=": "!=",
            "<": ">",
            ">": "<",
            "<=": ">=",
            ">=": "<="
        };

        /**
         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
         * @param {ASTNode} node The BinaryExpression node
         * @returns {string} A string representation of the node with the sides and operator flipped
         */
        function getFlippedString(node) {
<<<<<<< HEAD
            const operatorToken = sourceCode.getFirstTokenBetween(
                node.left,
                node.right,
                token => token.value === node.operator
            );
            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);
            const firstRightToken = sourceCode.getTokenAfter(operatorToken);

            const source = sourceCode.getText();

            const leftText = source.slice(
                node.range[0],
                lastLeftToken.range[1]
            );
            const textBeforeOperator = source.slice(
                lastLeftToken.range[1],
                operatorToken.range[0]
            );
            const textAfterOperator = source.slice(
                operatorToken.range[1],
                firstRightToken.range[0]
            );
            const rightText = source.slice(
                firstRightToken.range[0],
                node.range[1]
            );

            const tokenBefore = sourceCode.getTokenBefore(node);
            const tokenAfter = sourceCode.getTokenAfter(node);
            let prefix = "";
            let suffix = "";

            if (
                tokenBefore &&
                tokenBefore.range[1] === node.range[0] &&
                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)
            ) {
                prefix = " ";
            }

            if (
                tokenAfter &&
                node.range[1] === tokenAfter.range[0] &&
                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)
            ) {
                suffix = " ";
            }

            return (
                prefix +
                rightText +
                textBeforeOperator +
                OPERATOR_FLIP_MAP[operatorToken.value] +
                textAfterOperator +
                leftText +
                suffix
            );
=======
            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);

            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
        }

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            BinaryExpression(node) {
                const expectedLiteral = always ? node.left : node.right;
                const expectedNonLiteral = always ? node.right : node.left;

                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
                if (
<<<<<<< HEAD
                    (expectedNonLiteral.type === "Literal" ||
                        looksLikeLiteral(expectedNonLiteral)) &&
                    !(
                        expectedLiteral.type === "Literal" ||
                        looksLikeLiteral(expectedLiteral)
                    ) &&
                    !(!isEqualityOperator(node.operator) && onlyEquality) &&
                    isComparisonOperator(node.operator) &&
                    !(exceptRange && isRangeTest(node.parent))
                ) {
                    context.report({
                        node,
                        messageId: "expected",
=======
                    (expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) &&
                    !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) &&
                    !(!isEqualityOperator(node.operator) && onlyEquality) &&
                    isComparisonOperator(node.operator) &&
                    !(exceptRange && isRangeTest(context.getAncestors().pop()))
                ) {
                    context.report({
                        node,
                        message: "Expected literal to be on the {{expectedSide}} side of {{operator}}.",
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
                        data: {
                            operator: node.operator,
                            expectedSide: always ? "left" : "right"
                        },
<<<<<<< HEAD
                        fix: fixer =>
                            fixer.replaceText(node, getFlippedString(node))
                    });
                }
            }
        };
=======
                        fix: fixer => fixer.replaceText(node, getFlippedString(node))
                    });
                }

            }
        };

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
    }
};
