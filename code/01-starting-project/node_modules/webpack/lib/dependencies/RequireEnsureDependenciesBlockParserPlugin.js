/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD

"use strict";

const RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
const RequireEnsureDependency = require("./RequireEnsureDependency");
const RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
const getFunctionExpression = require("./getFunctionExpression");

/** @typedef {import("../ChunkGroup").ChunkGroupOptions} ChunkGroupOptions */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */

=======
"use strict";

const RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
const RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
const getFunctionExpression = require("./getFunctionExpression");

>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
module.exports = class RequireEnsureDependenciesBlockParserPlugin {
	apply(parser) {
		parser.hooks.call
			.for("require.ensure")
			.tap("RequireEnsureDependenciesBlockParserPlugin", expr => {
				let chunkName = null;
<<<<<<< HEAD
=======
				let chunkNameRange = null;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
				let errorExpressionArg = null;
				let errorExpression = null;
				switch (expr.arguments.length) {
					case 4: {
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!chunkNameExpr.isString()) return;
<<<<<<< HEAD
=======
						chunkNameRange = chunkNameExpr.range;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
						chunkName = chunkNameExpr.string;
					}
					// falls through
					case 3: {
						errorExpressionArg = expr.arguments[2];
						errorExpression = getFunctionExpression(errorExpressionArg);

						if (!errorExpression && !chunkName) {
							const chunkNameExpr = parser.evaluateExpression(
								expr.arguments[2]
							);
							if (!chunkNameExpr.isString()) return;
<<<<<<< HEAD
=======
							chunkNameRange = chunkNameExpr.range;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
							chunkName = chunkNameExpr.string;
						}
					}
					// falls through
					case 2: {
						const dependenciesExpr = parser.evaluateExpression(
							expr.arguments[0]
						);
						const dependenciesItems = dependenciesExpr.isArray()
							? dependenciesExpr.items
							: [dependenciesExpr];
						const successExpressionArg = expr.arguments[1];
<<<<<<< HEAD
						const successExpression =
							getFunctionExpression(successExpressionArg);
=======
						const successExpression = getFunctionExpression(
							successExpressionArg
						);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284

						if (successExpression) {
							parser.walkExpressions(successExpression.expressions);
						}
						if (errorExpression) {
							parser.walkExpressions(errorExpression.expressions);
						}

<<<<<<< HEAD
						const depBlock = new RequireEnsureDependenciesBlock(
							/** @type {ChunkGroupOptions & { entryOptions?: TODO }} */ (
								chunkName
							),
							expr.loc
						);
						const errorCallbackExists =
							expr.arguments.length === 4 ||
							(!chunkName && expr.arguments.length === 3);
						const dep = new RequireEnsureDependency(
							expr.range,
							expr.arguments[1].range,
							errorCallbackExists && expr.arguments[2].range
						);
						dep.loc = expr.loc;
						depBlock.addDependency(dep);
						const old = parser.state.current;
						parser.state.current = depBlock;
=======
						const dep = new RequireEnsureDependenciesBlock(
							expr,
							successExpression ? successExpression.fn : successExpressionArg,
							errorExpression ? errorExpression.fn : errorExpressionArg,
							chunkName,
							chunkNameRange,
							parser.state.module,
							expr.loc
						);
						const old = parser.state.current;
						parser.state.current = dep;
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
						try {
							let failed = false;
							parser.inScope([], () => {
								for (const ee of dependenciesItems) {
									if (ee.isString()) {
<<<<<<< HEAD
										const ensureDependency = new RequireEnsureItemDependency(
											ee.string
										);
										ensureDependency.loc = ee.loc || expr.loc;
										depBlock.addDependency(ensureDependency);
=======
										const edep = new RequireEnsureItemDependency(ee.string);
										edep.loc = dep.loc;
										dep.addDependency(edep);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
									} else {
										failed = true;
									}
								}
							});
							if (failed) {
								return;
							}
							if (successExpression) {
								if (successExpression.fn.body.type === "BlockStatement") {
									parser.walkStatement(successExpression.fn.body);
								} else {
									parser.walkExpression(successExpression.fn.body);
								}
							}
<<<<<<< HEAD
							old.addBlock(depBlock);
=======
							old.addBlock(dep);
>>>>>>> fb9087a8f6cdc7859ecd725957ccb7c04a787284
						} finally {
							parser.state.current = old;
						}
						if (!successExpression) {
							parser.walkExpression(successExpressionArg);
						}
						if (errorExpression) {
							if (errorExpression.fn.body.type === "BlockStatement") {
								parser.walkStatement(errorExpression.fn.body);
							} else {
								parser.walkExpression(errorExpression.fn.body);
							}
						} else if (errorExpressionArg) {
							parser.walkExpression(errorExpressionArg);
						}
						return true;
					}
				}
			});
	}
};
